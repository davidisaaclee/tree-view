(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventTargetMixin, TreeModel, extend,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  EventTargetMixin = require('oo-eventtarget');

  extend = function(obj, fields) {
    var key, result, value;
    result = {};
    for (key in obj) {
      value = obj[key];
      result[key] = value;
    }
    for (key in fields) {
      value = fields[key];
      result[key] = value;
    }
    return result;
  };


  /*
  Represents nested data as an ordered tree structure. Provides support for
  mutation observation. Can be used in conjunction with `TreeTransformer` to
  lazily and automatically transform between different tree representations.
   */

  TreeModel = (function() {

    /*
    Constructs a `TreeModel` with an optional value to hold.
    
    @param [a] value This node's held value.
     */
    function TreeModel(value1) {
      this.value = value1;
      this._bubble = bind(this._bubble, this);
      EventTargetMixin(this);

      /*
      @property [Array] Mapping of keys to this node's children, in the form:
        node: TreeModel
        key: String
       */
      this._children = {};

      /*
      @property [Array<String>] An ordered list of keys for this node's children.
       */
      this.orderedChildrenKeys = [];

      /*
      @property [Array<TreeModel>] An ordered list of this node's children.
       */
      Object.defineProperty(this, 'childList', {
        get: function() {
          return this.orderedChildrenKeys.map((function(_this) {
            return function(key) {
              return _this._children[key].node;
            };
          })(this));
        }
      });
    }


    /*
    @property [TreeModel] This node's parent node, or `null` if root.
     */

    TreeModel.prototype.parent = null;


    /*
    @property [String] The key by which this node's parent refers to this node,
      or `null` if root.
     */

    TreeModel.prototype.key = null;


    /*
    @param [String] key
    @return [TreeModel] The specified child node, or `null` if no such child.
     */

    TreeModel.prototype.getChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].node;
      } else {
        return null;
      }
    };


    /*
    Returns the index of the specified child, or `null` if no such child.
    
    @param [String] key
    @return [Integer] The index of the child at `key`, or `null` if no such child.
     */

    TreeModel.prototype.getIndexOfChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].index;
      } else {
        return null;
      }
    };


    /*
    @param [String] key
    @param [TreeModel] node
     */

    TreeModel.prototype.addChild = function(key, node) {
      return this._mutate((function(_this) {
        return function() {
          var index;
          if (key == null) {
            return null;
          }
          _this.removeChild(key);
          node.parent = _this;
          node.key = key;
          node.addEventListener('changed', _this._bubble(key));
          _this.orderedChildrenKeys.push(key);
          index = _this.orderedChildrenKeys.length - 1;
          _this._children[key] = {
            node: node,
            index: index
          };
          return _this._children[key].node;
        };
      })(this));
    };


    /*
    If a child exists at the specified key, replaces the child node at `key` with
      the specified node.
      If no such child exists, adds the node as a child at the specified key.
    
    @param [String] key The child's key.
    @param [TreeModel] node The node to put in the existing child's place.
    @return [TreeModel] The "adopted" child node (`node`)
     */

    TreeModel.prototype.setChild = function(key, node) {
      if (this._children[key] != null) {
        return this._mutate((function(_this) {
          return function() {
            return _this._children[key].node = node;
          };
        })(this));
      } else {
        return this.addChild(key, node);
      }
    };


    /*
    @param [String] key Key of child to be removed.
    @return [TreeModel] The removed child.
     */

    TreeModel.prototype.removeChild = function(key) {
      var toDelete;
      if (this._children[key] != null) {
        toDelete = this._children[key];
        return this._mutate((function(_this) {
          return function() {
            return toDelete.node._mutate(function() {
              var reorderChildren;
              toDelete.node.removeEventListener('changed', _this._bubble(key));
              toDelete.node.parent = null;
              toDelete.node.key = null;
              _this.orderedChildrenKeys.splice(_this._children[key].index, 1);
              delete _this._children[key];
              reorderChildren = function(startIndex) {
                var i, j, ref, ref1, results;
                results = [];
                for (i = j = ref = startIndex, ref1 = _this.orderedChildrenKeys.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
                  results.push(_this._children[_this.orderedChildrenKeys[i]].index = i);
                }
                return results;
              };
              reorderChildren(toDelete.index);
              return toDelete.node;
            });
          };
        })(this));
      }
    };


    /*
    Alias for `removeChild`.
    
    @param [String] key Key of child to be detached.
    @return [TreeModel] The detached child.
     */

    TreeModel.prototype.detach = function() {
      return this.removeChild.apply(this, arguments);
    };


    /*
    Creates a new node and places it at the provided path.
    
    Note: This is a mutating method, but the mutation is delegated to the
    new node's parent via `addChild`.
    
    @param [Array<String>] path The path where the new node should live.
    @param [a] value The value to be placed in the new node.
    @return [TreeModel<a>] The newly-created node, or `null` if invalid path.
     */

    TreeModel.prototype.put = function(arg, value) {
      var j, key, parent, parentPath;
      parentPath = 2 <= arg.length ? slice.call(arg, 0, j = arg.length - 1) : (j = 0, []), key = arg[j++];
      parent = this.navigate(parentPath);
      if ((parent != null) && (key != null)) {
        return parent.addChild(key, new TreeModel(value));
      } else {
        if (key == null) {
          throw new RangeError('Attempted to put value at an undefined key.');
        } else if (parent == null) {
          throw new RangeError('Attempted to put value at invalid path.');
        }
      }
    };


    /*
    Navigates to a node and returns that node if it exists.
    
    @param [Array<String>] path A path to the node, with the node's key as the last element.
    @return [TreeModel] The specified node, or `null` if no such node.
     */

    TreeModel.prototype.navigate = function(path) {
      var hd, ref, tl;
      hd = path[0], tl = 2 <= path.length ? slice.call(path, 1) : [];
      switch (false) {
        case hd == null:
          return (ref = this.getChild(hd)) != null ? ref.navigate(tl) : void 0;
        default:
          return this;
      }
    };


    /*
    Removes all children from this node.
    
    @return [TreeModel] This model.
     */

    TreeModel.prototype.clear = function() {
      return this._mutate((function(_this) {
        return function() {
          _this.orderedChildrenKeys.forEach(function(key) {
            return _this.removeChild(key);
          });
          return _this;
        };
      })(this));
    };


    /*
    Walks the tree depth-first, in order according to each node's `childList`,
      reducing to a single value.
    
    @param [Function<a, b, a>] procedure The reduction procedure, taking
      as parameters the accumulator value, and the current node's value; and
      returning the updated accumulator value.
    @param [a] accumulator The initial accumulator value.
     */

    TreeModel.prototype.reduce = function(procedure, accumulator) {
      this.childList.forEach(function(child) {
        return accumulator = child.reduce(procedure, accumulator);
      });
      return procedure(accumulator, this.value);
    };


    /*
    Perform a lot of mutations to this node or its descendants, only triggering
      a single change event.
    
    @param [Function<TreeModel, ?>] proc
     */

    TreeModel.prototype.batchMutate = function(proc) {
      return this._mutate((function(_this) {
        return function() {
          return proc(_this);
        };
      })(this));
    };


    /*
    Performs a mutation action, sending off changed events.
    
    @param [Function] procedure The action to perform.
    @return [?] The result of procedure.
     */

    TreeModel.prototype._mutate = function(procedure) {
      var r;
      if (!this._isMutating) {
        this._isMutating = true;
        r = procedure();
        this._fireChanged();
        this._isMutating = false;
        return r;
      } else {
        return procedure();
      }
    };


    /*
    Fires a changed event.
    
    @param [TreeModel] node The changed node.
     */

    TreeModel.prototype._fireChanged = function() {
      return this.dispatchEvent('changed', {
        node: this,
        path: []
      });
    };

    TreeModel.prototype._bubble = function(childKey) {
      return (function(_this) {
        return function(evt) {
          var data;
          if (!_this._isMutating) {
            data = extend(evt.data, {
              path: [childKey].concat(slice.call(evt.data.path))
            });
            return _this.dispatchEvent(evt.type, data);
          }
        };
      })(this);
    };

    return TreeModel;

  })();

  module.exports = TreeModel;

}).call(this);

},{"oo-eventtarget":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var TreeTransformer, firstMatch,
    slice = [].slice;

  firstMatch = function(l, val, matcher) {
    var i, j, len;
    for (j = 0, len = l.length; j < len; j++) {
      i = l[j];
      if (matcher(i, val)) {
        return i;
      }
    }
    return null;
  };

  TreeTransformer = (function() {

    /*
    Creates an empty `TreeTransformer`.
    
    @param [Function] makeDefaultTree Dependency injection for tree models. Should
      not require use of `new`.
     */
    function TreeTransformer(makeDefaultTree) {
      this.makeDefaultTree = makeDefaultTree;
      this._nodeCases = [];
    }


    /*
    Adds a transform for a node which passes the supplied predicate.
    
    @param [Function<a, TreeModel<a>, Boolean>] predicate
    @param [Function<a, TreeModel<a>, b>] transform
    @param [Function<a, TreeModel<a>>] treeConstructor
     */

    TreeTransformer.prototype.addNodeCase = function(predicate, transform, treeConstructor) {
      var nodeCase;
      if (treeConstructor == null) {
        treeConstructor = this.makeDefaultTree;
      }
      nodeCase = {
        predicate: predicate,
        transform: transform,
        constructor: treeConstructor
      };
      return this._nodeCases.push(nodeCase);
    };


    /*
    Transforms the provided tree model.
    
    @param [TreeModel] model The model to transform.
    @return [TreeModel] The transformed model.
     */

    TreeTransformer.prototype.transform = function(model) {
      var nodeCase, r;
      nodeCase = firstMatch(this._nodeCases, model, function(arg) {
        var predicate;
        predicate = arg.predicate;
        return predicate(model.value, model);
      });
      if (nodeCase != null) {
        r = nodeCase.constructor(nodeCase.transform(model.value, model));
        model.orderedChildrenKeys.forEach((function(_this) {
          return function(key) {
            var child, transformedChild;
            child = model.getChild(key);
            transformedChild = _this.transform(child);
            if (transformedChild != null) {
              return r.addChild(key, transformedChild);
            }
          };
        })(this));
        return r;
      } else {
        console.warn('No case matching node ', model);
        return null;
      }
    };


    /*
    Watches the provided tree model, calling the provided function when a
    transform occurs.
    
    @param [TreeModel] model The model to be watched and transformed.
    @param [Function<TreeModel, TreeModel, a>] onTransform Function which will be
      called when the model is transformed, providing the transformed and
      untransformed models as parameters.
    @param [Boolean] lazy `true` if this should only update changed branches.
    @param [Boolean] transformNow `true` if this method should immediately perform
      a transform upon being called; else, wait for the first modification.
    @return [Function] An unsubscribe function.
     */

    TreeTransformer.prototype.watch = function(model, onTransform, lazy, transformNow) {
      var cb, mostRecentResult;
      if (lazy == null) {
        lazy = true;
      }
      if (transformNow == null) {
        transformNow = true;
      }
      switch (lazy) {
        case false:
          cb = (function(_this) {
            return function() {
              return onTransform(_this.transform(model), model);
            };
          })(this);
          model.addEventListener('changed', cb);
          if (transformNow) {
            cb();
          }
          return function() {
            return model.removeEventListener('changed', cb);
          };
        case true:
          mostRecentResult = this.transform(model);
          cb = (function(_this) {
            return function(arg) {
              var branch, j, key, node, parentPath, path, ref;
              ref = arg.data, node = ref.node, path = ref.path;
              if (path.length === 0) {
                mostRecentResult = _this.transform(model);
              } else {
                branch = _this.transform(node);
                parentPath = 2 <= path.length ? slice.call(path, 0, j = path.length - 1) : (j = 0, []), key = path[j++];
                mostRecentResult.navigate(parentPath).setChild(key, branch);
              }
              return onTransform(mostRecentResult);
            };
          })(this);
          model.addEventListener('changed', cb);
          if (transformNow) {
            onTransform(mostRecentResult, model);
          }
          return function() {
            return model.removeEventListener('changed', cb);
          };
      }
    };

    return TreeTransformer;

  })();

  module.exports = TreeTransformer;

}).call(this);

},{}],3:[function(require,module,exports){
module.exports = require("./lib/$EventTarget.js");
},{"./lib/$EventTarget.js":4}],4:[function(require,module,exports){
/**
	$EventTarget mixin
	@author Bart Van Beurden
	@date 26/01/2014
**/

/**
	Events dispatched by $EventTarget have 3 properties:
	- type (string)
	- target (event source)
	- data (user-provided)
**/
var Event = function(type, target, data) {
	this.type = type;
	this.target = target;
	this.data = data;
};

/**
	$EventTarget mixin
	Extends an object with EventTarget methods
	(adds #addEventListener, #removeEventListener, #dispatchEvent)
	@param obj The object to extend
**/
module.exports = function(obj) {

	obj._listeners = {};
	var proto = Object.getPrototypeOf(obj);
	
	// if necessary, extend prototype
	if (!proto.addEventListener) {
	
		/**
			$EventTarget#addEventListener
			@param type The event Type to listen to
			@param callback(event) The listener function
			@returns this
		**/
		Object.defineProperty(proto, "addEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#addEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#addEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (!listeners) listeners = this._listeners[type] = [];
			listeners.push(callback);
			return this;
		}});
		
		/**
			$EventTarget#removeEventListener
			@param type The event Type to remove
			@param callback(event) The listener function to remove
			@returns this
		**/
		Object.defineProperty(proto, "removeEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#removeEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#removeEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (listeners) {
				var index = listeners.indexOf(callback);
				if (index != -1) {
					listeners.splice(index, 1);
					if (listeners.length == 0) delete this._listeners[type];
				}
			}
			return this;
		}});
		
		Object.defineProperty(proto, "clearEventListeners", { value: function(type) {
			
			if (arguments.length == 0) {
				this._listeners = {};
			} else {
				delete this._listeners[type];
			}
			return this;
		}});
		
		var dispatcher = function(event) { 
			return function(callback) { 
				callback(event);
			};
		};
		
		/**
			$EventTarget#dispatchEvent
			@param type The type of the event to dispatch
			@param data [Optional] The data to pass to the listeners
		**/
		Object.defineProperty(proto, "dispatchEvent", { value: function(type, data) {
			console.assert(typeof type == "string", "$EventTarget#dispatchEvent - type must be string");
			
			(this._listeners[type] || []).forEach(dispatcher(new Event(type, this, data)));
		}});
	};
	
	return obj;

};
},{}],5:[function(require,module,exports){
var TreeModel, TreeTransformer, makeBElement, makeDemoElement, nodeCount, rawModel, transformer, treeView;

TreeModel = require('TreeModel');

TreeTransformer = require('TreeTransformer');

makeDemoElement = function() {
  return new DemoElement();
};

makeBElement = function(model) {
  return function() {
    var button, content, elt;
    elt = document.createElement('span');
    elt.innerText = 'spanner';
    elt.classList.add('b');
    button = document.createElement('button');
    button.innerText = 'Add';
    elt.appendChild(button);
    button.addEventListener('click', function() {
      return model.put(["__reservedkey" + model.childList.length + "__"], {
        type: 'a'
      });
    });
    content = document.createElement('span');
    content.classList.add('children');
    content.classList.add('b-children');
    elt.appendChild(content);
    return elt;
  };
};

treeView = document.querySelector('#tree-view');

rawModel = new TreeModel({
  type: 'a'
});

transformer = new TreeTransformer(function(val) {
  return new TreeModel(val);
});

nodeCount = 0;

transformer.addNodeCase(function(val, model) {
  return val.type === 'a';
}, function(val, model) {
  return {
    instantiate: makeDemoElement,
    getChildrenInsertPoint: function(elm) {
      return elm;
    }
  };
});

(function(val) {
  var r;
  r = new TreeModel(val);
  r.nodeKind = "a" + (nodeCount++);
  return r;
});

transformer.addNodeCase(function(val, model) {
  return val.type === 'b';
}, function(val, model) {
  return {
    instantiate: makeBElement(model),
    getChildrenInsertPoint: function(elm) {
      return elm.querySelector('.children');
    }
  };
});

(function(val) {
  var r;
  r = new TreeModel(val);
  r.nodeKind = "b" + (nodeCount++);
  return r;
});

transformer.watch(rawModel, function(transformed, original) {
  return treeView.update(transformed);
});

rawModel.batchMutate(function(model) {
  model.put(['a'], {
    type: 'a'
  });
  model.put(['b'], {
    type: 'b'
  });
  model.put(['a', 'b1'], {
    type: 'b'
  });
  model.put(['a', 'a1'], {
    type: 'a'
  });
  model.put(['a', 'b2'], {
    type: 'b'
  });
  return model.put(['a', 'a2'], {
    type: 'a'
  });
});


},{"TreeModel":1,"TreeTransformer":2}]},{},[5])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvVHJlZU1vZGVsL2J1aWxkL1RyZWVNb2RlbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9UcmVlVHJhbnNmb3JtZXIvYnVpbGQvVHJlZVRyYW5zZm9ybWVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2xpYi8kRXZlbnRUYXJnZXQuanMiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvVHJlZVZpZXcvdHJlZS12aWV3L3NyYy9kZW1vL1RyZWVWaWV3RGVtby5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQSxJQUFBOztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsV0FBUjs7QUFDWixlQUFBLEdBQWtCLE9BQUEsQ0FBUSxpQkFBUjs7QUFHbEIsZUFB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QSxJQUFBLEVBQU0sR0FBTjtHQUFqQjtFQUNBLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELEVBQU0sSUFBTixDQUFWLEVBQXVCO0lBQUEsSUFBQSxFQUFNLEdBQU47R0FBdkI7RUFDQSxLQUFLLENBQUMsR0FBTixDQUFVLENBQUMsR0FBRCxFQUFNLElBQU4sQ0FBVixFQUF1QjtJQUFBLElBQUEsRUFBTSxHQUFOO0dBQXZCO0VBQ0EsS0FBSyxDQUFDLEdBQU4sQ0FBVSxDQUFDLEdBQUQsRUFBTSxJQUFOLENBQVYsRUFBdUI7SUFBQSxJQUFBLEVBQU0sR0FBTjtHQUF2QjtTQUNBLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELEVBQU0sSUFBTixDQUFWLEVBQXVCO0lBQUEsSUFBQSxFQUFNLEdBQU47R0FBdkI7QUFObUIsQ0FBckIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRUYXJnZXRNaXhpbiwgVHJlZU1vZGVsLCBleHRlbmQsXG4gICAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgc2xpY2UgPSBbXS5zbGljZTtcblxuICBFdmVudFRhcmdldE1peGluID0gcmVxdWlyZSgnb28tZXZlbnR0YXJnZXQnKTtcblxuICBleHRlbmQgPSBmdW5jdGlvbihvYmosIGZpZWxkcykge1xuICAgIHZhciBrZXksIHJlc3VsdCwgdmFsdWU7XG4gICAgcmVzdWx0ID0ge307XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gZmllbGRzKSB7XG4gICAgICB2YWx1ZSA9IGZpZWxkc1trZXldO1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuXG4gIC8qXG4gIFJlcHJlc2VudHMgbmVzdGVkIGRhdGEgYXMgYW4gb3JkZXJlZCB0cmVlIHN0cnVjdHVyZS4gUHJvdmlkZXMgc3VwcG9ydCBmb3JcbiAgbXV0YXRpb24gb2JzZXJ2YXRpb24uIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYFRyZWVUcmFuc2Zvcm1lcmAgdG9cbiAgbGF6aWx5IGFuZCBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybSBiZXR3ZWVuIGRpZmZlcmVudCB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICovXG5cbiAgVHJlZU1vZGVsID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLypcbiAgICBDb25zdHJ1Y3RzIGEgYFRyZWVNb2RlbGAgd2l0aCBhbiBvcHRpb25hbCB2YWx1ZSB0byBob2xkLlxuICAgIFxuICAgIEBwYXJhbSBbYV0gdmFsdWUgVGhpcyBub2RlJ3MgaGVsZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmVlTW9kZWwodmFsdWUxKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWUxO1xuICAgICAgdGhpcy5fYnViYmxlID0gYmluZCh0aGlzLl9idWJibGUsIHRoaXMpO1xuICAgICAgRXZlbnRUYXJnZXRNaXhpbih0aGlzKTtcblxuICAgICAgLypcbiAgICAgIEBwcm9wZXJ0eSBbQXJyYXldIE1hcHBpbmcgb2Yga2V5cyB0byB0aGlzIG5vZGUncyBjaGlsZHJlbiwgaW4gdGhlIGZvcm06XG4gICAgICAgIG5vZGU6IFRyZWVNb2RlbFxuICAgICAgICBrZXk6IFN0cmluZ1xuICAgICAgICovXG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuXG4gICAgICAvKlxuICAgICAgQHByb3BlcnR5IFtBcnJheTxTdHJpbmc+XSBBbiBvcmRlcmVkIGxpc3Qgb2Yga2V5cyBmb3IgdGhpcyBub2RlJ3MgY2hpbGRyZW4uXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3JkZXJlZENoaWxkcmVuS2V5cyA9IFtdO1xuXG4gICAgICAvKlxuICAgICAgQHByb3BlcnR5IFtBcnJheTxUcmVlTW9kZWw+XSBBbiBvcmRlcmVkIGxpc3Qgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2hpbGRMaXN0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRDaGlsZHJlbktleXMubWFwKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkcmVuW2tleV0ubm9kZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgQHByb3BlcnR5IFtUcmVlTW9kZWxdIFRoaXMgbm9kZSdzIHBhcmVudCBub2RlLCBvciBgbnVsbGAgaWYgcm9vdC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUucGFyZW50ID0gbnVsbDtcblxuXG4gICAgLypcbiAgICBAcHJvcGVydHkgW1N0cmluZ10gVGhlIGtleSBieSB3aGljaCB0aGlzIG5vZGUncyBwYXJlbnQgcmVmZXJzIHRvIHRoaXMgbm9kZSxcbiAgICAgIG9yIGBudWxsYCBpZiByb290LlxuICAgICAqL1xuXG4gICAgVHJlZU1vZGVsLnByb3RvdHlwZS5rZXkgPSBudWxsO1xuXG5cbiAgICAvKlxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXlcbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZSwgb3IgYG51bGxgIGlmIG5vIHN1Y2ggY2hpbGQuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldLm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQsIG9yIGBudWxsYCBpZiBubyBzdWNoIGNoaWxkLlxuICAgIFxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXlcbiAgICBAcmV0dXJuIFtJbnRlZ2VyXSBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIGF0IGBrZXlgLCBvciBgbnVsbGAgaWYgbm8gc3VjaCBjaGlsZC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuZ2V0SW5kZXhPZkNoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldLmluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBAcGFyYW0gW1N0cmluZ10ga2V5XG4gICAgQHBhcmFtIFtUcmVlTW9kZWxdIG5vZGVcbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihrZXksIG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdXRhdGUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoa2V5KTtcbiAgICAgICAgICBub2RlLnBhcmVudCA9IF90aGlzO1xuICAgICAgICAgIG5vZGUua2V5ID0ga2V5O1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlZCcsIF90aGlzLl9idWJibGUoa2V5KSk7XG4gICAgICAgICAgX3RoaXMub3JkZXJlZENoaWxkcmVuS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaW5kZXggPSBfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgX3RoaXMuX2NoaWxkcmVuW2tleV0gPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkcmVuW2tleV0ubm9kZTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIElmIGEgY2hpbGQgZXhpc3RzIGF0IHRoZSBzcGVjaWZpZWQga2V5LCByZXBsYWNlcyB0aGUgY2hpbGQgbm9kZSBhdCBga2V5YCB3aXRoXG4gICAgICB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICBJZiBubyBzdWNoIGNoaWxkIGV4aXN0cywgYWRkcyB0aGUgbm9kZSBhcyBhIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQga2V5LlxuICAgIFxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXkgVGhlIGNoaWxkJ3Mga2V5LlxuICAgIEBwYXJhbSBbVHJlZU1vZGVsXSBub2RlIFRoZSBub2RlIHRvIHB1dCBpbiB0aGUgZXhpc3RpbmcgY2hpbGQncyBwbGFjZS5cbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoZSBcImFkb3B0ZWRcIiBjaGlsZCBub2RlIChgbm9kZWApXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLnNldENoaWxkID0gZnVuY3Rpb24oa2V5LCBub2RlKSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhdGUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jaGlsZHJlbltrZXldLm5vZGUgPSBub2RlO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENoaWxkKGtleSwgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBAcGFyYW0gW1N0cmluZ10ga2V5IEtleSBvZiBjaGlsZCB0byBiZSByZW1vdmVkLlxuICAgIEByZXR1cm4gW1RyZWVNb2RlbF0gVGhlIHJlbW92ZWQgY2hpbGQuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgdG9EZWxldGU7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHRvRGVsZXRlID0gdGhpcy5fY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX211dGF0ZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9EZWxldGUubm9kZS5fbXV0YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcmVvcmRlckNoaWxkcmVuO1xuICAgICAgICAgICAgICB0b0RlbGV0ZS5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZWQnLCBfdGhpcy5fYnViYmxlKGtleSkpO1xuICAgICAgICAgICAgICB0b0RlbGV0ZS5ub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHRvRGVsZXRlLm5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXMub3JkZXJlZENoaWxkcmVuS2V5cy5zcGxpY2UoX3RoaXMuX2NoaWxkcmVuW2tleV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2NoaWxkcmVuW2tleV07XG4gICAgICAgICAgICAgIHJlb3JkZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZWYxLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gcmVmID0gc3RhcnRJbmRleCwgcmVmMSA9IF90aGlzLm9yZGVyZWRDaGlsZHJlbktleXMubGVuZ3RoOyByZWYgPD0gcmVmMSA/IGogPCByZWYxIDogaiA+IHJlZjE7IGkgPSByZWYgPD0gcmVmMSA/ICsraiA6IC0taikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKF90aGlzLl9jaGlsZHJlbltfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzW2ldXS5pbmRleCA9IGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVvcmRlckNoaWxkcmVuKHRvRGVsZXRlLmluZGV4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvRGVsZXRlLm5vZGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBBbGlhcyBmb3IgYHJlbW92ZUNoaWxkYC5cbiAgICBcbiAgICBAcGFyYW0gW1N0cmluZ10ga2V5IEtleSBvZiBjaGlsZCB0byBiZSBkZXRhY2hlZC5cbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoZSBkZXRhY2hlZCBjaGlsZC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgQ3JlYXRlcyBhIG5ldyBub2RlIGFuZCBwbGFjZXMgaXQgYXQgdGhlIHByb3ZpZGVkIHBhdGguXG4gICAgXG4gICAgTm90ZTogVGhpcyBpcyBhIG11dGF0aW5nIG1ldGhvZCwgYnV0IHRoZSBtdXRhdGlvbiBpcyBkZWxlZ2F0ZWQgdG8gdGhlXG4gICAgbmV3IG5vZGUncyBwYXJlbnQgdmlhIGBhZGRDaGlsZGAuXG4gICAgXG4gICAgQHBhcmFtIFtBcnJheTxTdHJpbmc+XSBwYXRoIFRoZSBwYXRoIHdoZXJlIHRoZSBuZXcgbm9kZSBzaG91bGQgbGl2ZS5cbiAgICBAcGFyYW0gW2FdIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBwbGFjZWQgaW4gdGhlIG5ldyBub2RlLlxuICAgIEByZXR1cm4gW1RyZWVNb2RlbDxhPl0gVGhlIG5ld2x5LWNyZWF0ZWQgbm9kZSwgb3IgYG51bGxgIGlmIGludmFsaWQgcGF0aC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oYXJnLCB2YWx1ZSkge1xuICAgICAgdmFyIGosIGtleSwgcGFyZW50LCBwYXJlbnRQYXRoO1xuICAgICAgcGFyZW50UGF0aCA9IDIgPD0gYXJnLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJnLCAwLCBqID0gYXJnLmxlbmd0aCAtIDEpIDogKGogPSAwLCBbXSksIGtleSA9IGFyZ1tqKytdO1xuICAgICAgcGFyZW50ID0gdGhpcy5uYXZpZ2F0ZShwYXJlbnRQYXRoKTtcbiAgICAgIGlmICgocGFyZW50ICE9IG51bGwpICYmIChrZXkgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5hZGRDaGlsZChrZXksIG5ldyBUcmVlTW9kZWwodmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0ZWQgdG8gcHV0IHZhbHVlIGF0IGFuIHVuZGVmaW5lZCBrZXkuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdGVkIHRvIHB1dCB2YWx1ZSBhdCBpbnZhbGlkIHBhdGguJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIE5hdmlnYXRlcyB0byBhIG5vZGUgYW5kIHJldHVybnMgdGhhdCBub2RlIGlmIGl0IGV4aXN0cy5cbiAgICBcbiAgICBAcGFyYW0gW0FycmF5PFN0cmluZz5dIHBhdGggQSBwYXRoIHRvIHRoZSBub2RlLCB3aXRoIHRoZSBub2RlJ3Mga2V5IGFzIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgQHJldHVybiBbVHJlZU1vZGVsXSBUaGUgc3BlY2lmaWVkIG5vZGUsIG9yIGBudWxsYCBpZiBubyBzdWNoIG5vZGUuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGhkLCByZWYsIHRsO1xuICAgICAgaGQgPSBwYXRoWzBdLCB0bCA9IDIgPD0gcGF0aC5sZW5ndGggPyBzbGljZS5jYWxsKHBhdGgsIDEpIDogW107XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgaGQgPT0gbnVsbDpcbiAgICAgICAgICByZXR1cm4gKHJlZiA9IHRoaXMuZ2V0Q2hpbGQoaGQpKSAhPSBudWxsID8gcmVmLm5hdmlnYXRlKHRsKSA6IHZvaWQgMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBub2RlLlxuICAgIFxuICAgIEByZXR1cm4gW1RyZWVNb2RlbF0gVGhpcyBtb2RlbC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdXRhdGUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlQ2hpbGQoa2V5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBXYWxrcyB0aGUgdHJlZSBkZXB0aC1maXJzdCwgaW4gb3JkZXIgYWNjb3JkaW5nIHRvIGVhY2ggbm9kZSdzIGBjaGlsZExpc3RgLFxuICAgICAgcmVkdWNpbmcgdG8gYSBzaW5nbGUgdmFsdWUuXG4gICAgXG4gICAgQHBhcmFtIFtGdW5jdGlvbjxhLCBiLCBhPl0gcHJvY2VkdXJlIFRoZSByZWR1Y3Rpb24gcHJvY2VkdXJlLCB0YWtpbmdcbiAgICAgIGFzIHBhcmFtZXRlcnMgdGhlIGFjY3VtdWxhdG9yIHZhbHVlLCBhbmQgdGhlIGN1cnJlbnQgbm9kZSdzIHZhbHVlOyBhbmRcbiAgICAgIHJldHVybmluZyB0aGUgdXBkYXRlZCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICBAcGFyYW0gW2FdIGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqL1xuXG4gICAgVHJlZU1vZGVsLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihwcm9jZWR1cmUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB0aGlzLmNoaWxkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvciA9IGNoaWxkLnJlZHVjZShwcm9jZWR1cmUsIGFjY3VtdWxhdG9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb2NlZHVyZShhY2N1bXVsYXRvciwgdGhpcy52YWx1ZSk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBQZXJmb3JtIGEgbG90IG9mIG11dGF0aW9ucyB0byB0aGlzIG5vZGUgb3IgaXRzIGRlc2NlbmRhbnRzLCBvbmx5IHRyaWdnZXJpbmdcbiAgICAgIGEgc2luZ2xlIGNoYW5nZSBldmVudC5cbiAgICBcbiAgICBAcGFyYW0gW0Z1bmN0aW9uPFRyZWVNb2RlbCwgPz5dIHByb2NcbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuYmF0Y2hNdXRhdGUgPSBmdW5jdGlvbihwcm9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbXV0YXRlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2MoX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgUGVyZm9ybXMgYSBtdXRhdGlvbiBhY3Rpb24sIHNlbmRpbmcgb2ZmIGNoYW5nZWQgZXZlbnRzLlxuICAgIFxuICAgIEBwYXJhbSBbRnVuY3Rpb25dIHByb2NlZHVyZSBUaGUgYWN0aW9uIHRvIHBlcmZvcm0uXG4gICAgQHJldHVybiBbP10gVGhlIHJlc3VsdCBvZiBwcm9jZWR1cmUuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLl9tdXRhdGUgPSBmdW5jdGlvbihwcm9jZWR1cmUpIHtcbiAgICAgIHZhciByO1xuICAgICAgaWYgKCF0aGlzLl9pc011dGF0aW5nKSB7XG4gICAgICAgIHRoaXMuX2lzTXV0YXRpbmcgPSB0cnVlO1xuICAgICAgICByID0gcHJvY2VkdXJlKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX2lzTXV0YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKCk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBGaXJlcyBhIGNoYW5nZWQgZXZlbnQuXG4gICAgXG4gICAgQHBhcmFtIFtUcmVlTW9kZWxdIG5vZGUgVGhlIGNoYW5nZWQgbm9kZS5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuX2ZpcmVDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KCdjaGFuZ2VkJywge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICBwYXRoOiBbXVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuX2J1YmJsZSA9IGZ1bmN0aW9uKGNoaWxkS2V5KSB7XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICBpZiAoIV90aGlzLl9pc011dGF0aW5nKSB7XG4gICAgICAgICAgICBkYXRhID0gZXh0ZW5kKGV2dC5kYXRhLCB7XG4gICAgICAgICAgICAgIHBhdGg6IFtjaGlsZEtleV0uY29uY2F0KHNsaWNlLmNhbGwoZXZ0LmRhdGEucGF0aCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5kaXNwYXRjaEV2ZW50KGV2dC50eXBlLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRyZWVNb2RlbDtcblxuICB9KSgpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gVHJlZU1vZGVsO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgVHJlZVRyYW5zZm9ybWVyLCBmaXJzdE1hdGNoLFxuICAgIHNsaWNlID0gW10uc2xpY2U7XG5cbiAgZmlyc3RNYXRjaCA9IGZ1bmN0aW9uKGwsIHZhbCwgbWF0Y2hlcikge1xuICAgIHZhciBpLCBqLCBsZW47XG4gICAgZm9yIChqID0gMCwgbGVuID0gbC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgaSA9IGxbal07XG4gICAgICBpZiAobWF0Y2hlcihpLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBUcmVlVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKlxuICAgIENyZWF0ZXMgYW4gZW1wdHkgYFRyZWVUcmFuc2Zvcm1lcmAuXG4gICAgXG4gICAgQHBhcmFtIFtGdW5jdGlvbl0gbWFrZURlZmF1bHRUcmVlIERlcGVuZGVuY3kgaW5qZWN0aW9uIGZvciB0cmVlIG1vZGVscy4gU2hvdWxkXG4gICAgICBub3QgcmVxdWlyZSB1c2Ugb2YgYG5ld2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJlZVRyYW5zZm9ybWVyKG1ha2VEZWZhdWx0VHJlZSkge1xuICAgICAgdGhpcy5tYWtlRGVmYXVsdFRyZWUgPSBtYWtlRGVmYXVsdFRyZWU7XG4gICAgICB0aGlzLl9ub2RlQ2FzZXMgPSBbXTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgQWRkcyBhIHRyYW5zZm9ybSBmb3IgYSBub2RlIHdoaWNoIHBhc3NlcyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlLlxuICAgIFxuICAgIEBwYXJhbSBbRnVuY3Rpb248YSwgVHJlZU1vZGVsPGE+LCBCb29sZWFuPl0gcHJlZGljYXRlXG4gICAgQHBhcmFtIFtGdW5jdGlvbjxhLCBUcmVlTW9kZWw8YT4sIGI+XSB0cmFuc2Zvcm1cbiAgICBAcGFyYW0gW0Z1bmN0aW9uPGEsIFRyZWVNb2RlbDxhPj5dIHRyZWVDb25zdHJ1Y3RvclxuICAgICAqL1xuXG4gICAgVHJlZVRyYW5zZm9ybWVyLnByb3RvdHlwZS5hZGROb2RlQ2FzZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdHJhbnNmb3JtLCB0cmVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHZhciBub2RlQ2FzZTtcbiAgICAgIGlmICh0cmVlQ29uc3RydWN0b3IgPT0gbnVsbCkge1xuICAgICAgICB0cmVlQ29uc3RydWN0b3IgPSB0aGlzLm1ha2VEZWZhdWx0VHJlZTtcbiAgICAgIH1cbiAgICAgIG5vZGVDYXNlID0ge1xuICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cmVlQ29uc3RydWN0b3JcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fbm9kZUNhc2VzLnB1c2gobm9kZUNhc2UpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgVHJhbnNmb3JtcyB0aGUgcHJvdmlkZWQgdHJlZSBtb2RlbC5cbiAgICBcbiAgICBAcGFyYW0gW1RyZWVNb2RlbF0gbW9kZWwgVGhlIG1vZGVsIHRvIHRyYW5zZm9ybS5cbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoZSB0cmFuc2Zvcm1lZCBtb2RlbC5cbiAgICAgKi9cblxuICAgIFRyZWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHZhciBub2RlQ2FzZSwgcjtcbiAgICAgIG5vZGVDYXNlID0gZmlyc3RNYXRjaCh0aGlzLl9ub2RlQ2FzZXMsIG1vZGVsLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgcHJlZGljYXRlID0gYXJnLnByZWRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZShtb2RlbC52YWx1ZSwgbW9kZWwpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm9kZUNhc2UgIT0gbnVsbCkge1xuICAgICAgICByID0gbm9kZUNhc2UuY29uc3RydWN0b3Iobm9kZUNhc2UudHJhbnNmb3JtKG1vZGVsLnZhbHVlLCBtb2RlbCkpO1xuICAgICAgICBtb2RlbC5vcmRlcmVkQ2hpbGRyZW5LZXlzLmZvckVhY2goKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkLCB0cmFuc2Zvcm1lZENoaWxkO1xuICAgICAgICAgICAgY2hpbGQgPSBtb2RlbC5nZXRDaGlsZChrZXkpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRDaGlsZCA9IF90aGlzLnRyYW5zZm9ybShjaGlsZCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByLmFkZENoaWxkKGtleSwgdHJhbnNmb3JtZWRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gY2FzZSBtYXRjaGluZyBub2RlICcsIG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBXYXRjaGVzIHRoZSBwcm92aWRlZCB0cmVlIG1vZGVsLCBjYWxsaW5nIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aGVuIGFcbiAgICB0cmFuc2Zvcm0gb2NjdXJzLlxuICAgIFxuICAgIEBwYXJhbSBbVHJlZU1vZGVsXSBtb2RlbCBUaGUgbW9kZWwgdG8gYmUgd2F0Y2hlZCBhbmQgdHJhbnNmb3JtZWQuXG4gICAgQHBhcmFtIFtGdW5jdGlvbjxUcmVlTW9kZWwsIFRyZWVNb2RlbCwgYT5dIG9uVHJhbnNmb3JtIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmVcbiAgICAgIGNhbGxlZCB3aGVuIHRoZSBtb2RlbCBpcyB0cmFuc2Zvcm1lZCwgcHJvdmlkaW5nIHRoZSB0cmFuc2Zvcm1lZCBhbmRcbiAgICAgIHVudHJhbnNmb3JtZWQgbW9kZWxzIGFzIHBhcmFtZXRlcnMuXG4gICAgQHBhcmFtIFtCb29sZWFuXSBsYXp5IGB0cnVlYCBpZiB0aGlzIHNob3VsZCBvbmx5IHVwZGF0ZSBjaGFuZ2VkIGJyYW5jaGVzLlxuICAgIEBwYXJhbSBbQm9vbGVhbl0gdHJhbnNmb3JtTm93IGB0cnVlYCBpZiB0aGlzIG1ldGhvZCBzaG91bGQgaW1tZWRpYXRlbHkgcGVyZm9ybVxuICAgICAgYSB0cmFuc2Zvcm0gdXBvbiBiZWluZyBjYWxsZWQ7IGVsc2UsIHdhaXQgZm9yIHRoZSBmaXJzdCBtb2RpZmljYXRpb24uXG4gICAgQHJldHVybiBbRnVuY3Rpb25dIEFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAqL1xuXG4gICAgVHJlZVRyYW5zZm9ybWVyLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKG1vZGVsLCBvblRyYW5zZm9ybSwgbGF6eSwgdHJhbnNmb3JtTm93KSB7XG4gICAgICB2YXIgY2IsIG1vc3RSZWNlbnRSZXN1bHQ7XG4gICAgICBpZiAobGF6eSA9PSBudWxsKSB7XG4gICAgICAgIGxhenkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU5vdyA9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybU5vdyA9IHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGxhenkpIHtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICBjYiA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gb25UcmFuc2Zvcm0oX3RoaXMudHJhbnNmb3JtKG1vZGVsKSwgbW9kZWwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgICBtb2RlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2VkJywgY2IpO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm1Ob3cpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2VkJywgY2IpO1xuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICBtb3N0UmVjZW50UmVzdWx0ID0gdGhpcy50cmFuc2Zvcm0obW9kZWwpO1xuICAgICAgICAgIGNiID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgIHZhciBicmFuY2gsIGosIGtleSwgbm9kZSwgcGFyZW50UGF0aCwgcGF0aCwgcmVmO1xuICAgICAgICAgICAgICByZWYgPSBhcmcuZGF0YSwgbm9kZSA9IHJlZi5ub2RlLCBwYXRoID0gcmVmLnBhdGg7XG4gICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1vc3RSZWNlbnRSZXN1bHQgPSBfdGhpcy50cmFuc2Zvcm0obW9kZWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyYW5jaCA9IF90aGlzLnRyYW5zZm9ybShub2RlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRQYXRoID0gMiA8PSBwYXRoLmxlbmd0aCA/IHNsaWNlLmNhbGwocGF0aCwgMCwgaiA9IHBhdGgubGVuZ3RoIC0gMSkgOiAoaiA9IDAsIFtdKSwga2V5ID0gcGF0aFtqKytdO1xuICAgICAgICAgICAgICAgIG1vc3RSZWNlbnRSZXN1bHQubmF2aWdhdGUocGFyZW50UGF0aCkuc2V0Q2hpbGQoa2V5LCBicmFuY2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvblRyYW5zZm9ybShtb3N0UmVjZW50UmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkodGhpcyk7XG4gICAgICAgICAgbW9kZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlZCcsIGNiKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtTm93KSB7XG4gICAgICAgICAgICBvblRyYW5zZm9ybShtb3N0UmVjZW50UmVzdWx0LCBtb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2VkJywgY2IpO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUcmVlVHJhbnNmb3JtZXI7XG5cbiAgfSkoKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRyZWVUcmFuc2Zvcm1lcjtcblxufSkuY2FsbCh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliLyRFdmVudFRhcmdldC5qc1wiKTsiLCIvKipcclxuXHQkRXZlbnRUYXJnZXQgbWl4aW5cclxuXHRAYXV0aG9yIEJhcnQgVmFuIEJldXJkZW5cclxuXHRAZGF0ZSAyNi8wMS8yMDE0XHJcbioqL1xyXG5cclxuLyoqXHJcblx0RXZlbnRzIGRpc3BhdGNoZWQgYnkgJEV2ZW50VGFyZ2V0IGhhdmUgMyBwcm9wZXJ0aWVzOlxyXG5cdC0gdHlwZSAoc3RyaW5nKVxyXG5cdC0gdGFyZ2V0IChldmVudCBzb3VyY2UpXHJcblx0LSBkYXRhICh1c2VyLXByb3ZpZGVkKVxyXG4qKi9cclxudmFyIEV2ZW50ID0gZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCBkYXRhKSB7XHJcblx0dGhpcy50eXBlID0gdHlwZTtcclxuXHR0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHR0aGlzLmRhdGEgPSBkYXRhO1xyXG59O1xyXG5cclxuLyoqXHJcblx0JEV2ZW50VGFyZ2V0IG1peGluXHJcblx0RXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCBFdmVudFRhcmdldCBtZXRob2RzXHJcblx0KGFkZHMgI2FkZEV2ZW50TGlzdGVuZXIsICNyZW1vdmVFdmVudExpc3RlbmVyLCAjZGlzcGF0Y2hFdmVudClcclxuXHRAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gZXh0ZW5kXHJcbioqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaikge1xyXG5cclxuXHRvYmouX2xpc3RlbmVycyA9IHt9O1xyXG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xyXG5cdFxyXG5cdC8vIGlmIG5lY2Vzc2FyeSwgZXh0ZW5kIHByb3RvdHlwZVxyXG5cdGlmICghcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHRcdCRFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyXHJcblx0XHRcdEBwYXJhbSB0eXBlIFRoZSBldmVudCBUeXBlIHRvIGxpc3RlbiB0b1xyXG5cdFx0XHRAcGFyYW0gY2FsbGJhY2soZXZlbnQpIFRoZSBsaXN0ZW5lciBmdW5jdGlvblxyXG5cdFx0XHRAcmV0dXJucyB0aGlzXHJcblx0XHQqKi9cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJhZGRFdmVudExpc3RlbmVyXCIsIHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XHJcblx0XHRcdGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIsIFwiJEV2ZW50VGFyZ2V0I2FkZEV2ZW50TGlzdGVuZXIgLSB0eXBlIG11c3QgYmUgc3RyaW5nXCIpO1xyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiLCBcIiRFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyIC0gY2FsbGJhY2sgbXVzdCBiZSBmdW5jdGlvblwiKTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XHJcblx0XHRcdGlmICghbGlzdGVuZXJzKSBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuXHRcdFx0bGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH19KTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHRcdCRFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyXHJcblx0XHRcdEBwYXJhbSB0eXBlIFRoZSBldmVudCBUeXBlIHRvIHJlbW92ZVxyXG5cdFx0XHRAcGFyYW0gY2FsbGJhY2soZXZlbnQpIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcclxuXHRcdFx0QHJldHVybnMgdGhpc1xyXG5cdFx0KiovXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLCB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiLCBcIiRFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyIC0gdHlwZSBtdXN0IGJlIHN0cmluZ1wiKTtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIiwgXCIkRXZlbnRUYXJnZXQjcmVtb3ZlRXZlbnRMaXN0ZW5lciAtIGNhbGxiYWNrIG11c3QgYmUgZnVuY3Rpb25cIik7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG5cdFx0XHRcdGlmIChpbmRleCAhPSAtMSkge1xyXG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PSAwKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH19KTtcclxuXHRcdFxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImNsZWFyRXZlbnRMaXN0ZW5lcnNcIiwgeyB2YWx1ZTogZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9fSk7XHJcblx0XHRcclxuXHRcdHZhciBkaXNwYXRjaGVyID0gZnVuY3Rpb24oZXZlbnQpIHsgXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykgeyBcclxuXHRcdFx0XHRjYWxsYmFjayhldmVudCk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdFx0JEV2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnRcclxuXHRcdFx0QHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGRpc3BhdGNoXHJcblx0XHRcdEBwYXJhbSBkYXRhIFtPcHRpb25hbF0gVGhlIGRhdGEgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJzXHJcblx0XHQqKi9cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJkaXNwYXRjaEV2ZW50XCIsIHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiwgXCIkRXZlbnRUYXJnZXQjZGlzcGF0Y2hFdmVudCAtIHR5cGUgbXVzdCBiZSBzdHJpbmdcIik7XHJcblx0XHRcdFxyXG5cdFx0XHQodGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGRpc3BhdGNoZXIobmV3IEV2ZW50KHR5cGUsIHRoaXMsIGRhdGEpKSk7XHJcblx0XHR9fSk7XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gb2JqO1xyXG5cclxufTsiLCJUcmVlTW9kZWwgPSByZXF1aXJlICdUcmVlTW9kZWwnXG5UcmVlVHJhbnNmb3JtZXIgPSByZXF1aXJlICdUcmVlVHJhbnNmb3JtZXInXG5cblxubWFrZURlbW9FbGVtZW50ID0gKCkgLT4gbmV3IERlbW9FbGVtZW50KClcblxubWFrZUJFbGVtZW50ID0gKG1vZGVsKSAtPlxuICAoKSAtPlxuICAgIGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ3NwYW4nXG4gICAgZWx0LmlubmVyVGV4dCA9ICdzcGFubmVyJ1xuICAgIGVsdC5jbGFzc0xpc3QuYWRkICdiJ1xuXG4gICAgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnYnV0dG9uJ1xuICAgIGJ1dHRvbi5pbm5lclRleHQgPSAnQWRkJ1xuICAgIGVsdC5hcHBlbmRDaGlsZCBidXR0b25cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lciAnY2xpY2snLCAoKSAtPlxuICAgICAgbW9kZWwucHV0IFtcIl9fcmVzZXJ2ZWRrZXkje21vZGVsLmNoaWxkTGlzdC5sZW5ndGh9X19cIl0sIHR5cGU6ICdhJ1xuXG4gICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ3NwYW4nXG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkICdjaGlsZHJlbidcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQgJ2ItY2hpbGRyZW4nXG5cbiAgICBlbHQuYXBwZW5kQ2hpbGQgY29udGVudFxuXG4gICAgcmV0dXJuIGVsdFxuXG50cmVlVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJyN0cmVlLXZpZXcnXG4jIHRyZWVWaWV3LmRpcmVjdEFwcGVuZCA9IHRydWVcbnJhd01vZGVsID0gbmV3IFRyZWVNb2RlbCB0eXBlOiAnYSdcbnRyYW5zZm9ybWVyID0gbmV3IFRyZWVUcmFuc2Zvcm1lciAodmFsKSAtPiBuZXcgVHJlZU1vZGVsIHZhbFxuXG5ub2RlQ291bnQgPSAwXG5cbnRyYW5zZm9ybWVyLmFkZE5vZGVDYXNlIFxcXG4gICh2YWwsIG1vZGVsKSAtPiB2YWwudHlwZSBpcyAnYScsXG4gICh2YWwsIG1vZGVsKSAtPlxuICAgIGluc3RhbnRpYXRlOiBtYWtlRGVtb0VsZW1lbnRcbiAgICAjIGdldENoaWxkcmVuSW5zZXJ0UG9pbnQ6IChlbG0pIC0+IGVsbS5xdWVyeVNlbGVjdG9yICcuY2hpbGRyZW4nLFxuICAgIGdldENoaWxkcmVuSW5zZXJ0UG9pbnQ6IChlbG0pIC0+IGVsbSxcbiAgKHZhbCkgLT5cbiAgICByID0gbmV3IFRyZWVNb2RlbCB2YWxcbiAgICByLm5vZGVLaW5kID0gXCJhI3tub2RlQ291bnQrK31cIlxuICAgIHJldHVybiByXG5cbnRyYW5zZm9ybWVyLmFkZE5vZGVDYXNlIFxcXG4gICh2YWwsIG1vZGVsKSAtPiB2YWwudHlwZSBpcyAnYicsXG4gICh2YWwsIG1vZGVsKSAtPlxuICAgIGluc3RhbnRpYXRlOiBtYWtlQkVsZW1lbnQgbW9kZWxcbiAgICBnZXRDaGlsZHJlbkluc2VydFBvaW50OiAoZWxtKSAtPiBlbG0ucXVlcnlTZWxlY3RvciAnLmNoaWxkcmVuJyxcbiAgKHZhbCkgLT5cbiAgICByID0gbmV3IFRyZWVNb2RlbCB2YWxcbiAgICByLm5vZGVLaW5kID0gXCJiI3tub2RlQ291bnQrK31cIlxuICAgIHJldHVybiByXG5cbnRyYW5zZm9ybWVyLndhdGNoIHJhd01vZGVsLCAodHJhbnNmb3JtZWQsIG9yaWdpbmFsKSAtPlxuICB0cmVlVmlldy51cGRhdGUgdHJhbnNmb3JtZWRcblxucmF3TW9kZWwuYmF0Y2hNdXRhdGUgKG1vZGVsKSAtPlxuICBtb2RlbC5wdXQgWydhJ10sIHR5cGU6ICdhJ1xuICBtb2RlbC5wdXQgWydiJ10sIHR5cGU6ICdiJ1xuICBtb2RlbC5wdXQgWydhJywgJ2IxJ10sIHR5cGU6ICdiJ1xuICBtb2RlbC5wdXQgWydhJywgJ2ExJ10sIHR5cGU6ICdhJ1xuICBtb2RlbC5wdXQgWydhJywgJ2IyJ10sIHR5cGU6ICdiJ1xuICBtb2RlbC5wdXQgWydhJywgJ2EyJ10sIHR5cGU6ICdhJyJdfQ==
