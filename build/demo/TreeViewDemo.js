(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventTargetMixin, TreeModel, extend,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  EventTargetMixin = require('oo-eventtarget');

  extend = function(obj, fields) {
    var key, result, value;
    result = {};
    for (key in obj) {
      value = obj[key];
      result[key] = value;
    }
    for (key in fields) {
      value = fields[key];
      result[key] = value;
    }
    return result;
  };


  /*
  Represents nested data as an ordered tree structure. Provides support for
  mutation observation. Can be used in conjunction with `TreeTransformer` to
  lazily and automatically transform between different tree representations.
   */

  TreeModel = (function() {

    /*
    Constructs a `TreeModel` with an optional value to hold.
    
    @param [a] value This node's held value.
     */
    function TreeModel(value1) {
      this.value = value1;
      this._bubble = bind(this._bubble, this);
      this._mutate((function(_this) {
        return function() {
          EventTargetMixin(_this);

          /*
          @property [Array] Mapping of keys to this node's children, in the form:
            node: TreeModel
            key: String
           */
          _this._children = {};

          /*
          @property [Array<String>] An ordered list of keys for this node's children.
           */
          _this.orderedChildrenKeys = [];

          /*
          @property [Array<TreeModel>] An ordered list of this node's children.
           */
          return Object.defineProperty(_this, 'childList', {
            get: function() {
              return this.orderedChildrenKeys.map((function(_this) {
                return function(key) {
                  return _this._children[key].node;
                };
              })(this));
            }
          });
        };
      })(this));
    }


    /*
    @param [String] key
    @return [TreeModel] The specified child node, or `null` if no such child.
     */

    TreeModel.prototype.getChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].node;
      } else {
        return null;
      }
    };


    /*
    Returns the index of the specified child, or `null` if no such child.
    
    @param [String] key
    @return [Integer] The index of the child at `key`, or `null` if no such child.
     */

    TreeModel.prototype.getIndexOfChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].index;
      } else {
        return null;
      }
    };


    /*
    @param [String] key
    @param [TreeModel] node
     */

    TreeModel.prototype.addChild = function(key, node) {
      return this._mutate((function(_this) {
        return function() {
          var index;
          if (key == null) {
            return null;
          }
          _this.removeChild(key);
          node.addEventListener('changed', _this._bubble(key));
          _this.orderedChildrenKeys.push(key);
          index = _this.orderedChildrenKeys.length - 1;
          _this._children[key] = {
            node: node,
            index: index
          };
          return _this._children[key].node;
        };
      })(this));
    };


    /*
    Replaces the child node at `key` with the specified node.
    If no such child exists, does nothing and returns `null`.
    
    @param [String] key The child's key.
    @param [TreeModel] node The node to put in the existing child's place.
    @return [TreeModel] The new child node (`node`), or `null` if no such child.
     */

    TreeModel.prototype.replaceChild = function(key, node) {
      if (this._children[key] != null) {
        return this._children[key].node = node;
      } else {
        return null;
      }
    };


    /*
    @param [String] key
     */

    TreeModel.prototype.removeChild = function(key) {
      return this._mutate((function(_this) {
        return function() {
          var reorderChildren, toDelete;
          if (_this._children[key] != null) {
            toDelete = _this._children[key];
            toDelete.node.removeEventListener('changed', _this._bubble(key));
            _this.orderedChildrenKeys.splice(_this._children[key].index, 1);
            delete _this._children[key];
            reorderChildren = function(startIndex) {
              var i, j, ref, ref1, results;
              results = [];
              for (i = j = ref = startIndex, ref1 = _this.orderedChildrenKeys.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
                results.push(_this._children[_this.orderedChildrenKeys[i]].index = i);
              }
              return results;
            };
            reorderChildren(toDelete.index);
            return toDelete.node;
          }
        };
      })(this));
    };


    /*
    Creates a new node and places it at the provided path.
    
    Note: This is a mutating method, but the mutation is delegated to the
    new node's parent via `addChild`.
    
    @param [Array<String>] path The path where the new node should live.
    @param [a] value The value to be placed in the new node.
    @return [TreeModel<a>] The newly-created node, or `null` if invalid path.
     */

    TreeModel.prototype.put = function(arg, value) {
      var j, key, parent, parentPath;
      parentPath = 2 <= arg.length ? slice.call(arg, 0, j = arg.length - 1) : (j = 0, []), key = arg[j++];
      parent = this.navigate(parentPath);
      if ((parent != null) && (key != null)) {
        return parent.addChild(key, new TreeModel(value));
      } else {
        if (key == null) {
          throw new RangeError('Attempted to put value at an undefined key.');
        } else if (parent == null) {
          throw new RangeError('Attempted to put value at invalid path.');
        }
      }
    };


    /*
    Navigates to a node and returns that node if it exists.
    
    @param [Array<String>] path A path to the node, with the node's key as the last element.
    @return [TreeModel] The specified node, or `null` if no such node.
     */

    TreeModel.prototype.navigate = function(path) {
      var hd, ref, tl;
      hd = path[0], tl = 2 <= path.length ? slice.call(path, 1) : [];
      switch (false) {
        case hd == null:
          return (ref = this.getChild(hd)) != null ? ref.navigate(tl) : void 0;
        default:
          return this;
      }
    };


    /*
    Removes all children from this node.
    
    @return [TreeModel] This model.
     */

    TreeModel.prototype.clear = function() {
      return this._mutate((function(_this) {
        return function() {
          _this.orderedChildrenKeys.forEach(function(key) {
            return _this.removeChild(key);
          });
          return _this;
        };
      })(this));
    };


    /*
     */

    TreeModel.prototype.batchMutate = function(proc) {
      return this._mutate((function(_this) {
        return function() {
          return proc(_this);
        };
      })(this));
    };


    /*
    Performs a mutation action, sending off changed events.
    
    @param [Function] procedure The action to perform.
    @return [?] The result of procedure.
     */

    TreeModel.prototype._mutate = function(procedure) {
      var r;
      if (!this._isMutating) {
        this._isMutating = true;
        r = procedure();
        this._fireChanged();
        this._isMutating = false;
        return r;
      } else {
        return procedure();
      }
    };


    /*
    Fires a changed event.
    
    @param [TreeModel] node The changed node.
     */

    TreeModel.prototype._fireChanged = function() {
      return this.dispatchEvent('changed', {
        node: this,
        path: []
      });
    };

    TreeModel.prototype._bubble = function(childKey) {
      return (function(_this) {
        return function(evt) {
          var data;
          if (!_this._isMutating) {
            data = extend(evt.data, {
              path: [childKey].concat(slice.call(evt.data.path))
            });
            return _this.dispatchEvent(evt.type, data);
          }
        };
      })(this);
    };

    return TreeModel;

  })();

  module.exports = TreeModel;

}).call(this);

},{"oo-eventtarget":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var TreeTransformer, firstMatch,
    slice = [].slice;

  firstMatch = function(l, val, matcher) {
    var i, j, len;
    for (j = 0, len = l.length; j < len; j++) {
      i = l[j];
      if (matcher(i, val)) {
        return i;
      }
    }
    return null;
  };

  TreeTransformer = (function() {

    /*
    Creates an empty `TreeTransformer`.
    
    @param [Function] TreeModelConstructor Dependency injection for tree models.
     */
    function TreeTransformer(TreeModelConstructor) {
      this.TreeModelConstructor = TreeModelConstructor;
      this._nodeCases = [];
    }


    /*
    Adds a transform for a node which passes the supplied predicate.
    
    @param [Function<a, TreeModel<a>, Boolean>] predicate
    @param [Function<a, TreeModel<a>, b>] transform
     */

    TreeTransformer.prototype.addNodeCase = function(predicate, transform) {
      var nodeCase;
      nodeCase = {
        predicate: predicate,
        transform: transform
      };
      return this._nodeCases.push(nodeCase);
    };


    /*
    Transforms the provided tree model.
    
    @param [TreeModel] model The model to transform.
    @return [TreeModel] The transformed model.
     */

    TreeTransformer.prototype.transform = function(model) {
      var nodeCase, r;
      nodeCase = firstMatch(this._nodeCases, model, function(arg) {
        var predicate;
        predicate = arg.predicate;
        return predicate(model.value, model);
      });
      if (nodeCase != null) {
        r = new this.TreeModelConstructor(nodeCase.transform(model.value, model));
        model.orderedChildrenKeys.forEach((function(_this) {
          return function(key) {
            var child, transformedChild;
            child = model.getChild(key);
            transformedChild = _this.transform(child);
            if (transformedChild != null) {
              return r.addChild(key, transformedChild);
            }
          };
        })(this));
        return r;
      } else {
        return null;
      }
    };


    /*
    Watches the provided tree model, calling the provided function when a
    transform occurs.
    
    @param [TreeModel] model The model to be watched and transformed.
    @param [Function<TreeModel, TreeModel, a>] onTransform Function which will be
      called when the model is transformed, providing the transformed and
      untransformed models as parameters.
    @param [Boolean] lazy `true` if this should only update changed branches.
    @return [Function] An unsubscribe function.
     */

    TreeTransformer.prototype.watch = function(model, onTransform, lazy) {
      var cb, mostRecentResult;
      if (lazy == null) {
        lazy = true;
      }
      switch (lazy) {
        case false:
          cb = (function(_this) {
            return function() {
              return onTransform(_this.transform(model), model);
            };
          })(this);
          model.addEventListener('changed', cb);
          return function() {
            return model.removeEventListener('changed', cb);
          };
        case true:
          mostRecentResult = this.transform(model);
          cb = (function(_this) {
            return function(arg) {
              var branch, j, key, node, parentPath, path, ref;
              ref = arg.data, node = ref.node, path = ref.path;
              if (path.length === 0) {
                mostRecentResult = _this.transform(model);
              } else {
                branch = _this.transform(node);
                parentPath = 2 <= path.length ? slice.call(path, 0, j = path.length - 1) : (j = 0, []), key = path[j++];
                mostRecentResult.navigate(parentPath).replaceChild(key, branch);
              }
              return onTransform(mostRecentResult);
            };
          })(this);
          model.addEventListener('changed', cb);
          return function() {
            return model.removeEventListener('changed', cb);
          };
      }
    };

    return TreeTransformer;

  })();

  module.exports = TreeTransformer;

}).call(this);

},{}],3:[function(require,module,exports){
module.exports = require("./lib/$EventTarget.js");
},{"./lib/$EventTarget.js":4}],4:[function(require,module,exports){
/**
	$EventTarget mixin
	@author Bart Van Beurden
	@date 26/01/2014
**/

/**
	Events dispatched by $EventTarget have 3 properties:
	- type (string)
	- target (event source)
	- data (user-provided)
**/
var Event = function(type, target, data) {
	this.type = type;
	this.target = target;
	this.data = data;
};

/**
	$EventTarget mixin
	Extends an object with EventTarget methods
	(adds #addEventListener, #removeEventListener, #dispatchEvent)
	@param obj The object to extend
**/
module.exports = function(obj) {

	obj._listeners = {};
	var proto = Object.getPrototypeOf(obj);
	
	// if necessary, extend prototype
	if (!proto.addEventListener) {
	
		/**
			$EventTarget#addEventListener
			@param type The event Type to listen to
			@param callback(event) The listener function
			@returns this
		**/
		Object.defineProperty(proto, "addEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#addEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#addEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (!listeners) listeners = this._listeners[type] = [];
			listeners.push(callback);
			return this;
		}});
		
		/**
			$EventTarget#removeEventListener
			@param type The event Type to remove
			@param callback(event) The listener function to remove
			@returns this
		**/
		Object.defineProperty(proto, "removeEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#removeEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#removeEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (listeners) {
				var index = listeners.indexOf(callback);
				if (index != -1) {
					listeners.splice(index, 1);
					if (listeners.length == 0) delete this._listeners[type];
				}
			}
			return this;
		}});
		
		Object.defineProperty(proto, "clearEventListeners", { value: function(type) {
			
			if (arguments.length == 0) {
				this._listeners = {};
			} else {
				delete this._listeners[type];
			}
			return this;
		}});
		
		var dispatcher = function(event) { 
			return function(callback) { 
				callback(event);
			};
		};
		
		/**
			$EventTarget#dispatchEvent
			@param type The type of the event to dispatch
			@param data [Optional] The data to pass to the listeners
		**/
		Object.defineProperty(proto, "dispatchEvent", { value: function(type, data) {
			console.assert(typeof type == "string", "$EventTarget#dispatchEvent - type must be string");
			
			(this._listeners[type] || []).forEach(dispatcher(new Event(type, this, data)));
		}});
	};
	
	return obj;

};
},{}],5:[function(require,module,exports){
var TreeModel, TreeTransformer, rawModel, rootView, transformer, treeView;

TreeModel = require('TreeModel');

TreeTransformer = require('TreeTransformer');

treeView = document.querySelector('#tree-view');

rootView = document.createElement('div');

rootView.classList.add('children');

rootView.classList.add('root');

treeView.model = new TreeModel(rootView);

rawModel = new TreeModel({
  type: 'a'
});

transformer = new TreeTransformer(TreeModel);

transformer.addNodeCase(function(val, model) {
  return val.type === 'a';
}, function(val, model) {
  return new DemoElement();
});

transformer.addNodeCase(function(val, model) {
  return val.type === 'b';
}, function(val, model) {
  var button, content, elt;
  elt = document.createElement('span');
  elt.innerText = 'spanner';
  elt.classList.add('b');
  button = document.createElement('button');
  button.innerText = 'Add';
  elt.appendChild(button);
  button.addEventListener('click', function() {
    return model.put(["__reservedkey" + model.childList.length + "__"], {
      type: 'a'
    });
  });
  content = document.createElement('span');
  content.classList.add('children');
  content.classList.add('b-children');
  elt.appendChild(content);
  return elt;
});

transformer.watch(rawModel, function(transformed, original) {
  treeView.model = transformed;
  return treeView.update();
});

rawModel.batchMutate(function(model) {
  model.put(['b'], {
    type: 'b'
  });
  model.put(['a'], {
    type: 'a'
  });
  model.put(['a', 'b1'], {
    type: 'b'
  });
  model.put(['a', 'a1'], {
    type: 'a'
  });
  model.put(['a', 'b2'], {
    type: 'b'
  });
  return model.put(['a', 'a2'], {
    type: 'a'
  });
});

setTimeout((function() {
  return console.log(treeView.model);
}), 1000);


},{"TreeModel":1,"TreeTransformer":2}]},{},[5])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvVHJlZU1vZGVsL2J1aWxkL1RyZWVNb2RlbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9UcmVlVHJhbnNmb3JtZXIvYnVpbGQvVHJlZVRyYW5zZm9ybWVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL29vLWV2ZW50dGFyZ2V0L2xpYi8kRXZlbnRUYXJnZXQuanMiLCIvVXNlcnMvZGF2aWQvRG9jdW1lbnRzL1dvcmsvVHJlZVZpZXcvdHJlZS12aWV3L3NyYy9kZW1vL1RyZWVWaWV3RGVtby5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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cUIsU0FBQyxLQUFEO0VBQ25CLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELENBQVYsRUFBaUI7SUFBQSxJQUFBLEVBQU0sR0FBTjtHQUFqQjtFQUNBLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELENBQVYsRUFBaUI7SUFBQSxJQUFBLEVBQU0sR0FBTjtHQUFqQjtFQUNBLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELEVBQU0sSUFBTixDQUFWLEVBQXVCO0lBQUEsSUFBQSxFQUFNLEdBQU47R0FBdkI7RUFDQSxLQUFLLENBQUMsR0FBTixDQUFVLENBQUMsR0FBRCxFQUFNLElBQU4sQ0FBVixFQUF1QjtJQUFBLElBQUEsRUFBTSxHQUFOO0dBQXZCO0VBQ0EsS0FBSyxDQUFDLEdBQU4sQ0FBVSxDQUFDLEdBQUQsRUFBTSxJQUFOLENBQVYsRUFBdUI7SUFBQSxJQUFBLEVBQU0sR0FBTjtHQUF2QjtTQUNBLEtBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQyxHQUFELEVBQU0sSUFBTixDQUFWLEVBQXVCO0lBQUEsSUFBQSxFQUFNLEdBQU47R0FBdkI7QUFObUIsQ0FBckI7O0FBUUEsVUFBQSxDQUFXLENBQUMsU0FBQTtTQUFNLE9BQU8sQ0FBQyxHQUFSLENBQVksUUFBUSxDQUFDLEtBQXJCO0FBQU4sQ0FBRCxDQUFYLEVBQStDLElBQS9DIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIEV2ZW50VGFyZ2V0TWl4aW4sIFRyZWVNb2RlbCwgZXh0ZW5kLFxuICAgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIHNsaWNlID0gW10uc2xpY2U7XG5cbiAgRXZlbnRUYXJnZXRNaXhpbiA9IHJlcXVpcmUoJ29vLWV2ZW50dGFyZ2V0Jyk7XG5cbiAgZXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBmaWVsZHMpIHtcbiAgICB2YXIga2V5LCByZXN1bHQsIHZhbHVlO1xuICAgIHJlc3VsdCA9IHt9O1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGZpZWxkcykge1xuICAgICAgdmFsdWUgPSBmaWVsZHNba2V5XTtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvKlxuICBSZXByZXNlbnRzIG5lc3RlZCBkYXRhIGFzIGFuIG9yZGVyZWQgdHJlZSBzdHJ1Y3R1cmUuIFByb3ZpZGVzIHN1cHBvcnQgZm9yXG4gIG11dGF0aW9uIG9ic2VydmF0aW9uLiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBUcmVlVHJhbnNmb3JtZXJgIHRvXG4gIGxhemlseSBhbmQgYXV0b21hdGljYWxseSB0cmFuc2Zvcm0gYmV0d2VlbiBkaWZmZXJlbnQgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAqL1xuXG4gIFRyZWVNb2RlbCA9IChmdW5jdGlvbigpIHtcblxuICAgIC8qXG4gICAgQ29uc3RydWN0cyBhIGBUcmVlTW9kZWxgIHdpdGggYW4gb3B0aW9uYWwgdmFsdWUgdG8gaG9sZC5cbiAgICBcbiAgICBAcGFyYW0gW2FdIHZhbHVlIFRoaXMgbm9kZSdzIGhlbGQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJlZU1vZGVsKHZhbHVlMSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlMTtcbiAgICAgIHRoaXMuX2J1YmJsZSA9IGJpbmQodGhpcy5fYnViYmxlLCB0aGlzKTtcbiAgICAgIHRoaXMuX211dGF0ZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEV2ZW50VGFyZ2V0TWl4aW4oX3RoaXMpO1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAcHJvcGVydHkgW0FycmF5XSBNYXBwaW5nIG9mIGtleXMgdG8gdGhpcyBub2RlJ3MgY2hpbGRyZW4sIGluIHRoZSBmb3JtOlxuICAgICAgICAgICAgbm9kZTogVHJlZU1vZGVsXG4gICAgICAgICAgICBrZXk6IFN0cmluZ1xuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLl9jaGlsZHJlbiA9IHt9O1xuXG4gICAgICAgICAgLypcbiAgICAgICAgICBAcHJvcGVydHkgW0FycmF5PFN0cmluZz5dIEFuIG9yZGVyZWQgbGlzdCBvZiBrZXlzIGZvciB0aGlzIG5vZGUncyBjaGlsZHJlbi5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzID0gW107XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgIEBwcm9wZXJ0eSBbQXJyYXk8VHJlZU1vZGVsPl0gQW4gb3JkZXJlZCBsaXN0IG9mIHRoaXMgbm9kZSdzIGNoaWxkcmVuLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsICdjaGlsZExpc3QnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzLm1hcCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NoaWxkcmVuW2tleV0ubm9kZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KSh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXlcbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoZSBzcGVjaWZpZWQgY2hpbGQgbm9kZSwgb3IgYG51bGxgIGlmIG5vIHN1Y2ggY2hpbGQuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldLm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQsIG9yIGBudWxsYCBpZiBubyBzdWNoIGNoaWxkLlxuICAgIFxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXlcbiAgICBAcmV0dXJuIFtJbnRlZ2VyXSBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIGF0IGBrZXlgLCBvciBgbnVsbGAgaWYgbm8gc3VjaCBjaGlsZC5cbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuZ2V0SW5kZXhPZkNoaWxkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAodGhpcy5fY2hpbGRyZW5ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldLmluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBAcGFyYW0gW1N0cmluZ10ga2V5XG4gICAgQHBhcmFtIFtUcmVlTW9kZWxdIG5vZGVcbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihrZXksIG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdXRhdGUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoa2V5KTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZWQnLCBfdGhpcy5fYnViYmxlKGtleSkpO1xuICAgICAgICAgIF90aGlzLm9yZGVyZWRDaGlsZHJlbktleXMucHVzaChrZXkpO1xuICAgICAgICAgIGluZGV4ID0gX3RoaXMub3JkZXJlZENoaWxkcmVuS2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgIF90aGlzLl9jaGlsZHJlbltrZXldID0ge1xuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9jaGlsZHJlbltrZXldLm5vZGU7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBSZXBsYWNlcyB0aGUgY2hpbGQgbm9kZSBhdCBga2V5YCB3aXRoIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICBJZiBubyBzdWNoIGNoaWxkIGV4aXN0cywgZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zIGBudWxsYC5cbiAgICBcbiAgICBAcGFyYW0gW1N0cmluZ10ga2V5IFRoZSBjaGlsZCdzIGtleS5cbiAgICBAcGFyYW0gW1RyZWVNb2RlbF0gbm9kZSBUaGUgbm9kZSB0byBwdXQgaW4gdGhlIGV4aXN0aW5nIGNoaWxkJ3MgcGxhY2UuXG4gICAgQHJldHVybiBbVHJlZU1vZGVsXSBUaGUgbmV3IGNoaWxkIG5vZGUgKGBub2RlYCksIG9yIGBudWxsYCBpZiBubyBzdWNoIGNoaWxkLlxuICAgICAqL1xuXG4gICAgVHJlZU1vZGVsLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbihrZXksIG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltrZXldICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV0ubm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIEBwYXJhbSBbU3RyaW5nXSBrZXlcbiAgICAgKi9cblxuICAgIFRyZWVNb2RlbC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tdXRhdGUoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVvcmRlckNoaWxkcmVuLCB0b0RlbGV0ZTtcbiAgICAgICAgICBpZiAoX3RoaXMuX2NoaWxkcmVuW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9EZWxldGUgPSBfdGhpcy5fY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgICAgIHRvRGVsZXRlLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlZCcsIF90aGlzLl9idWJibGUoa2V5KSk7XG4gICAgICAgICAgICBfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzLnNwbGljZShfdGhpcy5fY2hpbGRyZW5ba2V5XS5pbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuX2NoaWxkcmVuW2tleV07XG4gICAgICAgICAgICByZW9yZGVyQ2hpbGRyZW4gPSBmdW5jdGlvbihzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gaiA9IHJlZiA9IHN0YXJ0SW5kZXgsIHJlZjEgPSBfdGhpcy5vcmRlcmVkQ2hpbGRyZW5LZXlzLmxlbmd0aDsgcmVmIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goX3RoaXMuX2NoaWxkcmVuW190aGlzLm9yZGVyZWRDaGlsZHJlbktleXNbaV1dLmluZGV4ID0gaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVvcmRlckNoaWxkcmVuKHRvRGVsZXRlLmluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0b0RlbGV0ZS5ub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIENyZWF0ZXMgYSBuZXcgbm9kZSBhbmQgcGxhY2VzIGl0IGF0IHRoZSBwcm92aWRlZCBwYXRoLlxuICAgIFxuICAgIE5vdGU6IFRoaXMgaXMgYSBtdXRhdGluZyBtZXRob2QsIGJ1dCB0aGUgbXV0YXRpb24gaXMgZGVsZWdhdGVkIHRvIHRoZVxuICAgIG5ldyBub2RlJ3MgcGFyZW50IHZpYSBgYWRkQ2hpbGRgLlxuICAgIFxuICAgIEBwYXJhbSBbQXJyYXk8U3RyaW5nPl0gcGF0aCBUaGUgcGF0aCB3aGVyZSB0aGUgbmV3IG5vZGUgc2hvdWxkIGxpdmUuXG4gICAgQHBhcmFtIFthXSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgcGxhY2VkIGluIHRoZSBuZXcgbm9kZS5cbiAgICBAcmV0dXJuIFtUcmVlTW9kZWw8YT5dIFRoZSBuZXdseS1jcmVhdGVkIG5vZGUsIG9yIGBudWxsYCBpZiBpbnZhbGlkIHBhdGguXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGFyZywgdmFsdWUpIHtcbiAgICAgIHZhciBqLCBrZXksIHBhcmVudCwgcGFyZW50UGF0aDtcbiAgICAgIHBhcmVudFBhdGggPSAyIDw9IGFyZy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZywgMCwgaiA9IGFyZy5sZW5ndGggLSAxKSA6IChqID0gMCwgW10pLCBrZXkgPSBhcmdbaisrXTtcbiAgICAgIHBhcmVudCA9IHRoaXMubmF2aWdhdGUocGFyZW50UGF0aCk7XG4gICAgICBpZiAoKHBhcmVudCAhPSBudWxsKSAmJiAoa2V5ICE9IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuYWRkQ2hpbGQoa2V5LCBuZXcgVHJlZU1vZGVsKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdGVkIHRvIHB1dCB2YWx1ZSBhdCBhbiB1bmRlZmluZWQga2V5LicpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHRlZCB0byBwdXQgdmFsdWUgYXQgaW52YWxpZCBwYXRoLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBOYXZpZ2F0ZXMgdG8gYSBub2RlIGFuZCByZXR1cm5zIHRoYXQgbm9kZSBpZiBpdCBleGlzdHMuXG4gICAgXG4gICAgQHBhcmFtIFtBcnJheTxTdHJpbmc+XSBwYXRoIEEgcGF0aCB0byB0aGUgbm9kZSwgd2l0aCB0aGUgbm9kZSdzIGtleSBhcyB0aGUgbGFzdCBlbGVtZW50LlxuICAgIEByZXR1cm4gW1RyZWVNb2RlbF0gVGhlIHNwZWNpZmllZCBub2RlLCBvciBgbnVsbGAgaWYgbm8gc3VjaCBub2RlLlxuICAgICAqL1xuXG4gICAgVHJlZU1vZGVsLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBoZCwgcmVmLCB0bDtcbiAgICAgIGhkID0gcGF0aFswXSwgdGwgPSAyIDw9IHBhdGgubGVuZ3RoID8gc2xpY2UuY2FsbChwYXRoLCAxKSA6IFtdO1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIGhkID09IG51bGw6XG4gICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmdldENoaWxkKGhkKSkgIT0gbnVsbCA/IHJlZi5uYXZpZ2F0ZSh0bCkgOiB2b2lkIDA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgbm9kZS5cbiAgICBcbiAgICBAcmV0dXJuIFtUcmVlTW9kZWxdIFRoaXMgbW9kZWwuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbXV0YXRlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMub3JkZXJlZENoaWxkcmVuS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUNoaWxkKGtleSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLmJhdGNoTXV0YXRlID0gZnVuY3Rpb24ocHJvYykge1xuICAgICAgcmV0dXJuIHRoaXMuX211dGF0ZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBwcm9jKF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFBlcmZvcm1zIGEgbXV0YXRpb24gYWN0aW9uLCBzZW5kaW5nIG9mZiBjaGFuZ2VkIGV2ZW50cy5cbiAgICBcbiAgICBAcGFyYW0gW0Z1bmN0aW9uXSBwcm9jZWR1cmUgVGhlIGFjdGlvbiB0byBwZXJmb3JtLlxuICAgIEByZXR1cm4gWz9dIFRoZSByZXN1bHQgb2YgcHJvY2VkdXJlLlxuICAgICAqL1xuXG4gICAgVHJlZU1vZGVsLnByb3RvdHlwZS5fbXV0YXRlID0gZnVuY3Rpb24ocHJvY2VkdXJlKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIGlmICghdGhpcy5faXNNdXRhdGluZykge1xuICAgICAgICB0aGlzLl9pc011dGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgciA9IHByb2NlZHVyZSgpO1xuICAgICAgICB0aGlzLl9maXJlQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLl9pc011dGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZSgpO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qXG4gICAgRmlyZXMgYSBjaGFuZ2VkIGV2ZW50LlxuICAgIFxuICAgIEBwYXJhbSBbVHJlZU1vZGVsXSBub2RlIFRoZSBjaGFuZ2VkIG5vZGUuXG4gICAgICovXG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLl9maXJlQ2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudCgnY2hhbmdlZCcsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgcGF0aDogW11cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmVlTW9kZWwucHJvdG90eXBlLl9idWJibGUgPSBmdW5jdGlvbihjaGlsZEtleSkge1xuICAgICAgcmV0dXJuIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgaWYgKCFfdGhpcy5faXNNdXRhdGluZykge1xuICAgICAgICAgICAgZGF0YSA9IGV4dGVuZChldnQuZGF0YSwge1xuICAgICAgICAgICAgICBwYXRoOiBbY2hpbGRLZXldLmNvbmNhdChzbGljZS5jYWxsKGV2dC5kYXRhLnBhdGgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZGlzcGF0Y2hFdmVudChldnQudHlwZSwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmVlTW9kZWw7XG5cbiAgfSkoKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFRyZWVNb2RlbDtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIFRyZWVUcmFuc2Zvcm1lciwgZmlyc3RNYXRjaCxcbiAgICBzbGljZSA9IFtdLnNsaWNlO1xuXG4gIGZpcnN0TWF0Y2ggPSBmdW5jdGlvbihsLCB2YWwsIG1hdGNoZXIpIHtcbiAgICB2YXIgaSwgaiwgbGVuO1xuICAgIGZvciAoaiA9IDAsIGxlbiA9IGwubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGkgPSBsW2pdO1xuICAgICAgaWYgKG1hdGNoZXIoaSwgdmFsKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgVHJlZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLypcbiAgICBDcmVhdGVzIGFuIGVtcHR5IGBUcmVlVHJhbnNmb3JtZXJgLlxuICAgIFxuICAgIEBwYXJhbSBbRnVuY3Rpb25dIFRyZWVNb2RlbENvbnN0cnVjdG9yIERlcGVuZGVuY3kgaW5qZWN0aW9uIGZvciB0cmVlIG1vZGVscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmVlVHJhbnNmb3JtZXIoVHJlZU1vZGVsQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMuVHJlZU1vZGVsQ29uc3RydWN0b3IgPSBUcmVlTW9kZWxDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMuX25vZGVDYXNlcyA9IFtdO1xuICAgIH1cblxuXG4gICAgLypcbiAgICBBZGRzIGEgdHJhbnNmb3JtIGZvciBhIG5vZGUgd2hpY2ggcGFzc2VzIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gICAgXG4gICAgQHBhcmFtIFtGdW5jdGlvbjxhLCBUcmVlTW9kZWw8YT4sIEJvb2xlYW4+XSBwcmVkaWNhdGVcbiAgICBAcGFyYW0gW0Z1bmN0aW9uPGEsIFRyZWVNb2RlbDxhPiwgYj5dIHRyYW5zZm9ybVxuICAgICAqL1xuXG4gICAgVHJlZVRyYW5zZm9ybWVyLnByb3RvdHlwZS5hZGROb2RlQ2FzZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgbm9kZUNhc2U7XG4gICAgICBub2RlQ2FzZSA9IHtcbiAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuX25vZGVDYXNlcy5wdXNoKG5vZGVDYXNlKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFRyYW5zZm9ybXMgdGhlIHByb3ZpZGVkIHRyZWUgbW9kZWwuXG4gICAgXG4gICAgQHBhcmFtIFtUcmVlTW9kZWxdIG1vZGVsIFRoZSBtb2RlbCB0byB0cmFuc2Zvcm0uXG4gICAgQHJldHVybiBbVHJlZU1vZGVsXSBUaGUgdHJhbnNmb3JtZWQgbW9kZWwuXG4gICAgICovXG5cbiAgICBUcmVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICB2YXIgbm9kZUNhc2UsIHI7XG4gICAgICBub2RlQ2FzZSA9IGZpcnN0TWF0Y2godGhpcy5fbm9kZUNhc2VzLCBtb2RlbCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHZhciBwcmVkaWNhdGU7XG4gICAgICAgIHByZWRpY2F0ZSA9IGFyZy5wcmVkaWNhdGU7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUobW9kZWwudmFsdWUsIG1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vZGVDYXNlICE9IG51bGwpIHtcbiAgICAgICAgciA9IG5ldyB0aGlzLlRyZWVNb2RlbENvbnN0cnVjdG9yKG5vZGVDYXNlLnRyYW5zZm9ybShtb2RlbC52YWx1ZSwgbW9kZWwpKTtcbiAgICAgICAgbW9kZWwub3JkZXJlZENoaWxkcmVuS2V5cy5mb3JFYWNoKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCwgdHJhbnNmb3JtZWRDaGlsZDtcbiAgICAgICAgICAgIGNoaWxkID0gbW9kZWwuZ2V0Q2hpbGQoa2V5KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkQ2hpbGQgPSBfdGhpcy50cmFuc2Zvcm0oY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gci5hZGRDaGlsZChrZXksIHRyYW5zZm9ybWVkQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFdhdGNoZXMgdGhlIHByb3ZpZGVkIHRyZWUgbW9kZWwsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdoZW4gYVxuICAgIHRyYW5zZm9ybSBvY2N1cnMuXG4gICAgXG4gICAgQHBhcmFtIFtUcmVlTW9kZWxdIG1vZGVsIFRoZSBtb2RlbCB0byBiZSB3YXRjaGVkIGFuZCB0cmFuc2Zvcm1lZC5cbiAgICBAcGFyYW0gW0Z1bmN0aW9uPFRyZWVNb2RlbCwgVHJlZU1vZGVsLCBhPl0gb25UcmFuc2Zvcm0gRnVuY3Rpb24gd2hpY2ggd2lsbCBiZVxuICAgICAgY2FsbGVkIHdoZW4gdGhlIG1vZGVsIGlzIHRyYW5zZm9ybWVkLCBwcm92aWRpbmcgdGhlIHRyYW5zZm9ybWVkIGFuZFxuICAgICAgdW50cmFuc2Zvcm1lZCBtb2RlbHMgYXMgcGFyYW1ldGVycy5cbiAgICBAcGFyYW0gW0Jvb2xlYW5dIGxhenkgYHRydWVgIGlmIHRoaXMgc2hvdWxkIG9ubHkgdXBkYXRlIGNoYW5nZWQgYnJhbmNoZXMuXG4gICAgQHJldHVybiBbRnVuY3Rpb25dIEFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAqL1xuXG4gICAgVHJlZVRyYW5zZm9ybWVyLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKG1vZGVsLCBvblRyYW5zZm9ybSwgbGF6eSkge1xuICAgICAgdmFyIGNiLCBtb3N0UmVjZW50UmVzdWx0O1xuICAgICAgaWYgKGxhenkgPT0gbnVsbCkge1xuICAgICAgICBsYXp5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobGF6eSkge1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgIGNiID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvblRyYW5zZm9ybShfdGhpcy50cmFuc2Zvcm0obW9kZWwpLCBtb2RlbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKHRoaXMpO1xuICAgICAgICAgIG1vZGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZWQnLCBjYik7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZWQnLCBjYik7XG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgIG1vc3RSZWNlbnRSZXN1bHQgPSB0aGlzLnRyYW5zZm9ybShtb2RlbCk7XG4gICAgICAgICAgY2IgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgdmFyIGJyYW5jaCwgaiwga2V5LCBub2RlLCBwYXJlbnRQYXRoLCBwYXRoLCByZWY7XG4gICAgICAgICAgICAgIHJlZiA9IGFyZy5kYXRhLCBub2RlID0gcmVmLm5vZGUsIHBhdGggPSByZWYucGF0aDtcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbW9zdFJlY2VudFJlc3VsdCA9IF90aGlzLnRyYW5zZm9ybShtb2RlbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJhbmNoID0gX3RoaXMudHJhbnNmb3JtKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBhcmVudFBhdGggPSAyIDw9IHBhdGgubGVuZ3RoID8gc2xpY2UuY2FsbChwYXRoLCAwLCBqID0gcGF0aC5sZW5ndGggLSAxKSA6IChqID0gMCwgW10pLCBrZXkgPSBwYXRoW2orK107XG4gICAgICAgICAgICAgICAgbW9zdFJlY2VudFJlc3VsdC5uYXZpZ2F0ZShwYXJlbnRQYXRoKS5yZXBsYWNlQ2hpbGQoa2V5LCBicmFuY2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvblRyYW5zZm9ybShtb3N0UmVjZW50UmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkodGhpcyk7XG4gICAgICAgICAgbW9kZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlZCcsIGNiKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlZCcsIGNiKTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVHJlZVRyYW5zZm9ybWVyO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBUcmVlVHJhbnNmb3JtZXI7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi8kRXZlbnRUYXJnZXQuanNcIik7IiwiLyoqXHJcblx0JEV2ZW50VGFyZ2V0IG1peGluXHJcblx0QGF1dGhvciBCYXJ0IFZhbiBCZXVyZGVuXHJcblx0QGRhdGUgMjYvMDEvMjAxNFxyXG4qKi9cclxuXHJcbi8qKlxyXG5cdEV2ZW50cyBkaXNwYXRjaGVkIGJ5ICRFdmVudFRhcmdldCBoYXZlIDMgcHJvcGVydGllczpcclxuXHQtIHR5cGUgKHN0cmluZylcclxuXHQtIHRhcmdldCAoZXZlbnQgc291cmNlKVxyXG5cdC0gZGF0YSAodXNlci1wcm92aWRlZClcclxuKiovXHJcbnZhciBFdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZGF0YSkge1xyXG5cdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcblx0dGhpcy5kYXRhID0gZGF0YTtcclxufTtcclxuXHJcbi8qKlxyXG5cdCRFdmVudFRhcmdldCBtaXhpblxyXG5cdEV4dGVuZHMgYW4gb2JqZWN0IHdpdGggRXZlbnRUYXJnZXQgbWV0aG9kc1xyXG5cdChhZGRzICNhZGRFdmVudExpc3RlbmVyLCAjcmVtb3ZlRXZlbnRMaXN0ZW5lciwgI2Rpc3BhdGNoRXZlbnQpXHJcblx0QHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGV4dGVuZFxyXG4qKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmopIHtcclxuXHJcblx0b2JqLl9saXN0ZW5lcnMgPSB7fTtcclxuXHR2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcclxuXHRcclxuXHQvLyBpZiBuZWNlc3NhcnksIGV4dGVuZCBwcm90b3R5cGVcclxuXHRpZiAoIXByb3RvLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0XHQkRXZlbnRUYXJnZXQjYWRkRXZlbnRMaXN0ZW5lclxyXG5cdFx0XHRAcGFyYW0gdHlwZSBUaGUgZXZlbnQgVHlwZSB0byBsaXN0ZW4gdG9cclxuXHRcdFx0QHBhcmFtIGNhbGxiYWNrKGV2ZW50KSBUaGUgbGlzdGVuZXIgZnVuY3Rpb25cclxuXHRcdFx0QHJldHVybnMgdGhpc1xyXG5cdFx0KiovXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwiYWRkRXZlbnRMaXN0ZW5lclwiLCB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRjb25zb2xlLmFzc2VydCh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiLCBcIiRFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyIC0gdHlwZSBtdXN0IGJlIHN0cmluZ1wiKTtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIiwgXCIkRXZlbnRUYXJnZXQjYWRkRXZlbnRMaXN0ZW5lciAtIGNhbGxiYWNrIG11c3QgYmUgZnVuY3Rpb25cIik7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHRpZiAoIWxpc3RlbmVycykgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XHJcblx0XHRcdGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9fSk7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0XHQkRXZlbnRUYXJnZXQjcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG5cdFx0XHRAcGFyYW0gdHlwZSBUaGUgZXZlbnQgVHlwZSB0byByZW1vdmVcclxuXHRcdFx0QHBhcmFtIGNhbGxiYWNrKGV2ZW50KSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXHJcblx0XHRcdEByZXR1cm5zIHRoaXNcclxuXHRcdCoqL1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgeyB2YWx1ZTogZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcclxuXHRcdFx0Y29uc29sZS5hc3NlcnQodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiwgXCIkRXZlbnRUYXJnZXQjcmVtb3ZlRXZlbnRMaXN0ZW5lciAtIHR5cGUgbXVzdCBiZSBzdHJpbmdcIik7XHJcblx0XHRcdGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBjYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIsIFwiJEV2ZW50VGFyZ2V0I3JlbW92ZUV2ZW50TGlzdGVuZXIgLSBjYWxsYmFjayBtdXN0IGJlIGZ1bmN0aW9uXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuXHRcdFx0XHRpZiAoaW5kZXggIT0gLTEpIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT0gMCkgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9fSk7XHJcblx0XHRcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJjbGVhckV2ZW50TGlzdGVuZXJzXCIsIHsgdmFsdWU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuXHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fX0pO1xyXG5cdFx0XHJcblx0XHR2YXIgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKGV2ZW50KSB7IFxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHsgXHJcblx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHRcdCRFdmVudFRhcmdldCNkaXNwYXRjaEV2ZW50XHJcblx0XHRcdEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaFxyXG5cdFx0XHRAcGFyYW0gZGF0YSBbT3B0aW9uYWxdIFRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyc1xyXG5cdFx0KiovXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwiZGlzcGF0Y2hFdmVudFwiLCB7IHZhbHVlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XHJcblx0XHRcdGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIsIFwiJEV2ZW50VGFyZ2V0I2Rpc3BhdGNoRXZlbnQgLSB0eXBlIG11c3QgYmUgc3RyaW5nXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0KHRoaXMuX2xpc3RlbmVyc1t0eXBlXSB8fCBbXSkuZm9yRWFjaChkaXNwYXRjaGVyKG5ldyBFdmVudCh0eXBlLCB0aGlzLCBkYXRhKSkpO1xyXG5cdFx0fX0pO1xyXG5cdH07XHJcblx0XHJcblx0cmV0dXJuIG9iajtcclxuXHJcbn07IiwiVHJlZU1vZGVsID0gcmVxdWlyZSAnVHJlZU1vZGVsJ1xuVHJlZVRyYW5zZm9ybWVyID0gcmVxdWlyZSAnVHJlZVRyYW5zZm9ybWVyJ1xuXG50cmVlVmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJyN0cmVlLXZpZXcnXG5cbnJvb3RWaWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnZGl2J1xucm9vdFZpZXcuY2xhc3NMaXN0LmFkZCAnY2hpbGRyZW4nXG5yb290Vmlldy5jbGFzc0xpc3QuYWRkICdyb290J1xudHJlZVZpZXcubW9kZWwgPSBuZXcgVHJlZU1vZGVsIHJvb3RWaWV3XG5cbnJhd01vZGVsID0gbmV3IFRyZWVNb2RlbCB0eXBlOiAnYSdcblxudHJhbnNmb3JtZXIgPSBuZXcgVHJlZVRyYW5zZm9ybWVyIFRyZWVNb2RlbFxuXG50cmFuc2Zvcm1lci5hZGROb2RlQ2FzZSBcXFxuICAodmFsLCBtb2RlbCkgLT4gdmFsLnR5cGUgaXMgJ2EnLFxuICAodmFsLCBtb2RlbCkgLT4gbmV3IERlbW9FbGVtZW50KClcblxudHJhbnNmb3JtZXIuYWRkTm9kZUNhc2UgXFxcbiAgKHZhbCwgbW9kZWwpIC0+IHZhbC50eXBlIGlzICdiJyxcbiAgKHZhbCwgbW9kZWwpIC0+XG4gICAgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnc3BhbidcbiAgICBlbHQuaW5uZXJUZXh0ID0gJ3NwYW5uZXInXG4gICAgZWx0LmNsYXNzTGlzdC5hZGQgJ2InXG5cbiAgICBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICdidXR0b24nXG4gICAgYnV0dG9uLmlubmVyVGV4dCA9ICdBZGQnXG4gICAgZWx0LmFwcGVuZENoaWxkIGJ1dHRvblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyICdjbGljaycsICgpIC0+XG4gICAgICBtb2RlbC5wdXQgW1wiX19yZXNlcnZlZGtleSN7bW9kZWwuY2hpbGRMaXN0Lmxlbmd0aH1fX1wiXSxcbiAgICAgICAgdHlwZTogJ2EnXG5cbiAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAnc3BhbidcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQgJ2NoaWxkcmVuJ1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCAnYi1jaGlsZHJlbidcblxuICAgIGVsdC5hcHBlbmRDaGlsZCBjb250ZW50XG5cbiAgICByZXR1cm4gZWx0XG5cblxudHJhbnNmb3JtZXIud2F0Y2ggcmF3TW9kZWwsICh0cmFuc2Zvcm1lZCwgb3JpZ2luYWwpIC0+XG4gIHRyZWVWaWV3Lm1vZGVsID0gdHJhbnNmb3JtZWRcbiAgdHJlZVZpZXcudXBkYXRlKClcblxuXG5yYXdNb2RlbC5iYXRjaE11dGF0ZSAobW9kZWwpIC0+XG4gIG1vZGVsLnB1dCBbJ2InXSwgdHlwZTogJ2InXG4gIG1vZGVsLnB1dCBbJ2EnXSwgdHlwZTogJ2EnXG4gIG1vZGVsLnB1dCBbJ2EnLCAnYjEnXSwgdHlwZTogJ2InXG4gIG1vZGVsLnB1dCBbJ2EnLCAnYTEnXSwgdHlwZTogJ2EnXG4gIG1vZGVsLnB1dCBbJ2EnLCAnYjInXSwgdHlwZTogJ2InXG4gIG1vZGVsLnB1dCBbJ2EnLCAnYTInXSwgdHlwZTogJ2EnXG5cbnNldFRpbWVvdXQgKCgpIC0+IGNvbnNvbGUubG9nIHRyZWVWaWV3Lm1vZGVsKSwgMTAwMCJdfQ==
